
I2C.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000001a0  00000000  00000000  00000074  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000000  00800060  000001a0  00000214  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .stab         000006cc  00000000  00000000  00000214  2**2
                  CONTENTS, READONLY, DEBUGGING
  3 .stabstr      00000085  00000000  00000000  000008e0  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_aranges 000000c0  00000000  00000000  00000968  2**3
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   0000056a  00000000  00000000  00000a28  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 00000116  00000000  00000000  00000f92  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   000003a5  00000000  00000000  000010a8  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  000000b8  00000000  00000000  00001450  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    0000012a  00000000  00000000  00001508  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    0000009f  00000000  00000000  00001632  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
   4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
   8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
   c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  1c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
  54:	11 24       	eor	r1, r1
  56:	1f be       	out	0x3f, r1	; 63
  58:	cf e5       	ldi	r28, 0x5F	; 95
  5a:	d8 e0       	ldi	r29, 0x08	; 8
  5c:	de bf       	out	0x3e, r29	; 62
  5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
  60:	10 e0       	ldi	r17, 0x00	; 0
  62:	a0 e6       	ldi	r26, 0x60	; 96
  64:	b0 e0       	ldi	r27, 0x00	; 0
  66:	e0 ea       	ldi	r30, 0xA0	; 160
  68:	f1 e0       	ldi	r31, 0x01	; 1
  6a:	02 c0       	rjmp	.+4      	; 0x70 <__do_copy_data+0x10>
  6c:	05 90       	lpm	r0, Z+
  6e:	0d 92       	st	X+, r0
  70:	a0 36       	cpi	r26, 0x60	; 96
  72:	b1 07       	cpc	r27, r17
  74:	d9 f7       	brne	.-10     	; 0x6c <__do_copy_data+0xc>

00000076 <__do_clear_bss>:
  76:	10 e0       	ldi	r17, 0x00	; 0
  78:	a0 e6       	ldi	r26, 0x60	; 96
  7a:	b0 e0       	ldi	r27, 0x00	; 0
  7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
  7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
  80:	a0 36       	cpi	r26, 0x60	; 96
  82:	b1 07       	cpc	r27, r17
  84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
  86:	0e 94 49 00 	call	0x92	; 0x92 <main>
  8a:	0c 94 ce 00 	jmp	0x19c	; 0x19c <_exit>

0000008e <__bad_interrupt>:
  8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <main>:


#include <avr/io.h>

int main(void)
{
  92:	ff cf       	rjmp	.-2      	; 0x92 <main>

00000094 <I2C_master_vinit>:
#include <avr/io.h>
#include "std_macros.h" 

//=========================== I2C Initialization =============================
void I2C_master_vinit(unsigned long clock)
{
  94:	9b 01       	movw	r18, r22
  96:	ac 01       	movw	r20, r24
    // Set prescaler bits
    if (PRESCALER == 1)
        TWSR = 0;
  98:	11 b8       	out	0x01, r1	; 1
        TWSR = (1 << TWPS1);
    else if (PRESCALER == 64)
        TWSR = (1 << TWPS0) | (1 << TWPS1);

    // Set bit rate
    TWBR = (uint8_t)(((F_CPU / clock) - 16) / (2 * PRESCALER));
  9a:	60 e0       	ldi	r22, 0x00	; 0
  9c:	72 e1       	ldi	r23, 0x12	; 18
  9e:	8a e7       	ldi	r24, 0x7A	; 122
  a0:	90 e0       	ldi	r25, 0x00	; 0
  a2:	0e 94 ac 00 	call	0x158	; 0x158 <__udivmodsi4>
  a6:	da 01       	movw	r26, r20
  a8:	c9 01       	movw	r24, r18
  aa:	40 97       	sbiw	r24, 0x10	; 16
  ac:	a1 09       	sbc	r26, r1
  ae:	b1 09       	sbc	r27, r1
  b0:	b6 95       	lsr	r27
  b2:	a7 95       	ror	r26
  b4:	97 95       	ror	r25
  b6:	87 95       	ror	r24
  b8:	80 b9       	out	0x00, r24	; 0
}
  ba:	08 95       	ret

000000bc <I2C_Error>:

//=========================== Error Handler =============================
void I2C_Error()
{
    SET_BIT(DDRC, 3);     // Set PC3 as output
  bc:	a3 9a       	sbi	0x14, 3	; 20
    TOG_BIT(PORTC, 3);    // Toggle PC3 to indicate error
  be:	95 b3       	in	r25, 0x15	; 21
  c0:	88 e0       	ldi	r24, 0x08	; 8
  c2:	89 27       	eor	r24, r25
  c4:	85 bb       	out	0x15, r24	; 21
}
  c6:	08 95       	ret

000000c8 <I2C_Start>:

//=========================== Start Condition =============================
void I2C_Start()
{
    TWCR = (1 << TWSTA) | (1 << TWEN) | (1 << TWINT);
  c8:	84 ea       	ldi	r24, 0xA4	; 164
  ca:	86 bf       	out	0x36, r24	; 54
    while (!(TWCR & (1 << TWINT)));
  cc:	06 b6       	in	r0, 0x36	; 54
  ce:	07 fe       	sbrs	r0, 7
  d0:	fd cf       	rjmp	.-6      	; 0xcc <I2C_Start+0x4>

    if ((TWSR & 0xF8) != 0x08)  // START transmitted
  d2:	81 b1       	in	r24, 0x01	; 1
  d4:	88 7f       	andi	r24, 0xF8	; 248
  d6:	88 30       	cpi	r24, 0x08	; 8
  d8:	11 f0       	breq	.+4      	; 0xde <I2C_Start+0x16>
        I2C_Error();
  da:	0e 94 5e 00 	call	0xbc	; 0xbc <I2C_Error>
  de:	08 95       	ret

000000e0 <I2C_Write_address>:
}

//=========================== Send Slave Address + R/W Bit =============================
void I2C_Write_address(uint8_t address, uint8_t direction)
{
    TWDR = (address << 1) | (direction & 0x01);
  e0:	96 2f       	mov	r25, r22
  e2:	91 70       	andi	r25, 0x01	; 1
  e4:	88 0f       	add	r24, r24
  e6:	98 2b       	or	r25, r24
  e8:	93 b9       	out	0x03, r25	; 3
    TWCR = (1 << TWEN) | (1 << TWINT); 
  ea:	84 e8       	ldi	r24, 0x84	; 132
  ec:	86 bf       	out	0x36, r24	; 54
    while (!(TWCR & (1 << TWINT)));
  ee:	06 b6       	in	r0, 0x36	; 54
  f0:	07 fe       	sbrs	r0, 7
  f2:	fd cf       	rjmp	.-6      	; 0xee <I2C_Write_address+0xe>


    if ((direction == 0 && (TWSR & 0xF8) != 0x18) || (direction == 1 && (TWSR & 0xF8) != 0x40)) {
  f4:	66 23       	and	r22, r22
  f6:	29 f4       	brne	.+10     	; 0x102 <I2C_Write_address+0x22>
  f8:	81 b1       	in	r24, 0x01	; 1
  fa:	88 7f       	andi	r24, 0xF8	; 248
  fc:	88 31       	cpi	r24, 0x18	; 24
  fe:	39 f4       	brne	.+14     	; 0x10e <I2C_Write_address+0x2e>
 100:	08 95       	ret
 102:	61 30       	cpi	r22, 0x01	; 1
 104:	31 f4       	brne	.+12     	; 0x112 <I2C_Write_address+0x32>
 106:	81 b1       	in	r24, 0x01	; 1
 108:	88 7f       	andi	r24, 0xF8	; 248
 10a:	80 34       	cpi	r24, 0x40	; 64
 10c:	11 f0       	breq	.+4      	; 0x112 <I2C_Write_address+0x32>
        I2C_Error();
 10e:	0e 94 5e 00 	call	0xbc	; 0xbc <I2C_Error>
 112:	08 95       	ret

00000114 <I2C_Write_data>:
}

//=========================== Write Data =============================
void I2C_Write_data(uint8_t data)
{
    TWDR = data;
 114:	83 b9       	out	0x03, r24	; 3
    TWCR = (1 << TWEN) | (1 << TWINT); // Start transmission
 116:	84 e8       	ldi	r24, 0x84	; 132
 118:	86 bf       	out	0x36, r24	; 54
    while (!(TWCR & (1 << TWINT)));
 11a:	06 b6       	in	r0, 0x36	; 54
 11c:	07 fe       	sbrs	r0, 7
 11e:	fd cf       	rjmp	.-6      	; 0x11a <I2C_Write_data+0x6>
    if ((TWSR & 0xF8) != 0x28)  // Data transmitted + ACK
 120:	81 b1       	in	r24, 0x01	; 1
 122:	88 7f       	andi	r24, 0xF8	; 248
 124:	88 32       	cpi	r24, 0x28	; 40
 126:	11 f0       	breq	.+4      	; 0x12c <I2C_Write_data+0x18>
        I2C_Error();
 128:	0e 94 5e 00 	call	0xbc	; 0xbc <I2C_Error>
 12c:	08 95       	ret

0000012e <I2C_stop>:
}

//=========================== Stop Condition =============================
void I2C_stop()
{
    TWCR = (1 << TWEN) | (1 << TWINT) | (1 << TWSTO);
 12e:	84 e9       	ldi	r24, 0x94	; 148
 130:	86 bf       	out	0x36, r24	; 54
    // No need to wait for TWINT here
}
 132:	08 95       	ret

00000134 <I2C_slave_address>:

//=========================== Slave Address Setup (for slave mode only) =============================
void I2C_slave_address(uint8_t address, uint8_t general_call)
{
    TWAR = (address << 1) | (general_call & 0x01);
 134:	61 70       	andi	r22, 0x01	; 1
 136:	88 0f       	add	r24, r24
 138:	68 2b       	or	r22, r24
 13a:	62 b9       	out	0x02, r22	; 2
}
 13c:	08 95       	ret

0000013e <I2C_slave_read>:

unsigned char I2C_slave_read()
{
	
	TWCR = (1 << TWEN) | (1 << TWINT) | (1 << TWEA);
 13e:	84 ec       	ldi	r24, 0xC4	; 196
 140:	86 bf       	out	0x36, r24	; 54
	while(READ_BIT(TWCR,TWINT) == 0 );
 142:	06 b6       	in	r0, 0x36	; 54
 144:	07 fe       	sbrs	r0, 7
 146:	fd cf       	rjmp	.-6      	; 0x142 <I2C_slave_read+0x4>
	if ((TWSR & 0xF8) != 0x80)  // Data transmitted + ACK
 148:	81 b1       	in	r24, 0x01	; 1
 14a:	88 7f       	andi	r24, 0xF8	; 248
 14c:	80 38       	cpi	r24, 0x80	; 128
 14e:	11 f0       	breq	.+4      	; 0x154 <I2C_slave_read+0x16>
	I2C_Error();
 150:	0e 94 5e 00 	call	0xbc	; 0xbc <I2C_Error>
	return TWDR;
 154:	83 b1       	in	r24, 0x03	; 3
}
 156:	08 95       	ret

00000158 <__udivmodsi4>:
 158:	a1 e2       	ldi	r26, 0x21	; 33
 15a:	1a 2e       	mov	r1, r26
 15c:	aa 1b       	sub	r26, r26
 15e:	bb 1b       	sub	r27, r27
 160:	fd 01       	movw	r30, r26
 162:	0d c0       	rjmp	.+26     	; 0x17e <__udivmodsi4_ep>

00000164 <__udivmodsi4_loop>:
 164:	aa 1f       	adc	r26, r26
 166:	bb 1f       	adc	r27, r27
 168:	ee 1f       	adc	r30, r30
 16a:	ff 1f       	adc	r31, r31
 16c:	a2 17       	cp	r26, r18
 16e:	b3 07       	cpc	r27, r19
 170:	e4 07       	cpc	r30, r20
 172:	f5 07       	cpc	r31, r21
 174:	20 f0       	brcs	.+8      	; 0x17e <__udivmodsi4_ep>
 176:	a2 1b       	sub	r26, r18
 178:	b3 0b       	sbc	r27, r19
 17a:	e4 0b       	sbc	r30, r20
 17c:	f5 0b       	sbc	r31, r21

0000017e <__udivmodsi4_ep>:
 17e:	66 1f       	adc	r22, r22
 180:	77 1f       	adc	r23, r23
 182:	88 1f       	adc	r24, r24
 184:	99 1f       	adc	r25, r25
 186:	1a 94       	dec	r1
 188:	69 f7       	brne	.-38     	; 0x164 <__udivmodsi4_loop>
 18a:	60 95       	com	r22
 18c:	70 95       	com	r23
 18e:	80 95       	com	r24
 190:	90 95       	com	r25
 192:	9b 01       	movw	r18, r22
 194:	ac 01       	movw	r20, r24
 196:	bd 01       	movw	r22, r26
 198:	cf 01       	movw	r24, r30
 19a:	08 95       	ret

0000019c <_exit>:
 19c:	f8 94       	cli

0000019e <__stop_program>:
 19e:	ff cf       	rjmp	.-2      	; 0x19e <__stop_program>
